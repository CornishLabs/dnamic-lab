from typing import List, Set
import logging

# core device drivers
from artiq.coredevice.core import Core
from artiq.coredevice.ad9910 import AD9910 # This is per ch
from artiq.coredevice.urukul import CPLD # This is the whole urukul controller
from artiq.coredevice.ttl import TTLOut
from artiq.coredevice.zotino import Zotino
from artiq.coredevice.suservo import Channel, SUServo
from artiq.coredevice.sampler import Sampler

from artiq.experiment import EnvExperiment

# artiq
from artiq.language.units import MHz, dB, us, V
from artiq.language.core import delay, kernel, delay_mu

# ndscan concepts
from ndscan.experiment import Fragment, ExpFragment, make_fragment_scan_exp, create_and_run_fragment_once

logger = logging.getLogger(__name__)

def is_ttl_name(s: str) -> bool:
    """
    Check whether a name is likely a hardware TTL (autogenerated),
    assumes <100 TTLs.
    """
    return s.startswith("ttl") and len(s) > 3 and len(s) < 6 and s[3:].isdigit()


class InitialiseHardware(ExpFragment):
    """
    Discover and initialise hardware once per scan run.

    Important:
      - Stand-alone Urukul DDS/CPLDs are kept separate from SUServo-owned DDS/CPLDs.
      - They are initialized in separate kernels so the ARTIQ compiler does not have
        to unify incompatible AD9910/CPLD object layouts.
    
    Has method `safe_off_initial_state` to start hardware in safe state.
    """


    def build_fragment(self):
        self.setattr_device("core")
        self.core: Core

        self._did_rtio_init = False

        kernel_invariants = getattr(self, "kernel_invariants", set())
        self.kernel_invariants = kernel_invariants | {
            "standalone_urukul_cplds",
            "standalone_ad9910s",
            "suservos",
            "suservo_channels",
            "zotinos",
            "samplers",
            "ttls",
        }

    def host_setup(self):
        super().host_setup()

        if self._did_rtio_init:
            return
        self._did_rtio_init = True

        self._discover_devices()

        logger.info(
            "Init: %d standalone CPLDs, %d standalone AD9910, %d SUServo, %d SUServo channels, %d Zotino, %d Samplers, %d TTLs",
            len(self.standalone_urukul_cplds),
            len(self.standalone_ad9910s),
            len(self.suservos),
            len(self.suservo_channels),
            len(self.zotinos),
            len(self.samplers),
            len(self.ttls),
        )

        # Separate kernel entry points: do NOT wrap these in one umbrella kernel.
        self.rtio_init_standalone()
        # self.rtio_init_suservos()

    def _discover_devices(self):
        db = self.get_device_db()

        # First collect which DDS/CPLDs are owned by SUServo.
        suservo_dds_names: Set[str] = set()
        suservo_cpld_names: Set[str] = set()

        suservo_names: List[str] = []
        suservo_channel_names: List[str] = []
        zotino_names: List[str] = []
        sampler_names: List[str] = []
        ttl_names: List[str] = []

        for name, desc in db.items():
            if not isinstance(desc, dict):
                continue

            cls = desc.get("class", "")
            args = desc.get("arguments", {}) or {}

            if cls == "SUServo":
                suservo_names.append(name)

                for dds_name in args.get("dds_devices", []):
                    suservo_dds_names.add(dds_name)

                for cpld_name in args.get("cpld_devices", []):
                    suservo_cpld_names.add(cpld_name)

            elif cls == "Channel":
                suservo_channel_names.append(name)

            elif cls == "Zotino":
                zotino_names.append(name)

            elif cls == "Sampler":
                sampler_names.append(name)

            elif cls == "TTLOut" and is_ttl_name(name):
                ttl_names.append(name)

        # Now collect only stand-alone Urukul devices.
        standalone_cpld_names: List[str] = []
        standalone_ad9910_names: List[str] = []

        for name, desc in db.items():
            if not isinstance(desc, dict):
                continue

            cls = desc.get("class", "")
            args = desc.get("arguments", {}) or {}

            if cls == "CPLD" and name not in suservo_cpld_names:
                standalone_cpld_names.append(name)

            elif cls == "AD9910" and name not in suservo_dds_names:
                standalone_ad9910_names.append(name)

        # Resolve host-side device objects
        self.standalone_urukul_cplds: List[CPLD] = [
            self.get_device(n) for n in standalone_cpld_names
        ]
        self.standalone_ad9910s: List[AD9910] = [
            self.get_device(n) for n in standalone_ad9910_names
        ]

        self.suservos = [self.get_device(n) for n in suservo_names]
        self.suservo_channels = [
            self.get_device(n) for n in suservo_channel_names
        ]
        self.zotinos: List[Zotino] = [self.get_device(n) for n in zotino_names]
        self.samplers: List[Sampler] = [self.get_device(n) for n in sampler_names]
        self.ttls: List[TTLOut] = [self.get_device(n) for n in ttl_names]

    @kernel
    def rtio_init_standalone(self):
        self.core.reset()

        # Stand-alone Urukul CPLDs first.
        for cpld in self.standalone_urukul_cplds:
            cpld.init()

        self.core.break_realtime()
        # Then stand-alone DDS channels.
        for dds in self.standalone_ad9910s:
            dds.init()

        self.core.break_realtime()
        # DACs
        for zotino in self.zotinos:
            zotino.init()

        self.core.break_realtime()
        # Non-SUServo samplers
        for sampler in self.samplers:
            sampler.init()

    @kernel
    def rtio_init_suservos(self):
        self.core.break_realtime()

        # SUServo.init() internally touches its own CPLDs and DDSes.
        # These have a different SyncDelaySeed class to the normal delay seeds,
        # so this needs to be it's own kernel

        for suservo in self.suservos:
            suservo.init()

    @kernel
    def safe_off(self):
        for ttl in self.ttls:
            ttl.off()
            delay_mu(8)

        for dds in self.standalone_ad9910s:
            dds.cfg_sw(False) # Use ttl switches (faster)
            dds.sw.off()
            dds.set_profile(0)
            delay(2*us)
            dds.set_att(0 * dB)
            delay(2*us)

        for zotino in self.zotinos:
            zotino.set_dac([0.0] * 32)

        self.core.break_realtime()

        # Safest route before set_y(): stop servo iterations first.
        for suservo in self.suservos:
            suservo.set_config(enable=0)
        delay(3 * us)

        for channel in self.suservo_channels:
            channel.set(en_out=0, en_iir=0, profile=0)
        delay(3 * us)

        for channel in self.suservo_channels:
            channel.set_y(profile=0, y=0.0)
    
    @kernel
    def run_once(self):
        self.core.break_realtime()
        self.safe_off()


class SetSafeStateExperiment(EnvExperiment):
    def run(self):
        create_and_run_fragment_once(self, InitialiseHardware)