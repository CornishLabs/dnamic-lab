from contextlib import suppress
from typing import List, Set
import logging

# core device drivers
from artiq.coredevice.core import Core
from artiq.coredevice.ad9910 import AD9910 # This is per ch
from artiq.coredevice.urukul import CPLD # This is the whole urukul controller
from artiq.coredevice.ttl import TTLOut
from artiq.coredevice.zotino import Zotino
from artiq.coredevice.suservo import Channel
from artiq.coredevice.suservo import SUServo
from artiq.coredevice.sampler import Sampler

# artiq
from artiq.language.units import MHz, dB, s, ms, us, V
from artiq.language.core import delay, kernel, rpc

# ndscan concepts
from ndscan.experiment.parameters import FloatParam, FloatParamHandle
from ndscan.experiment import Fragment, ExpFragment, OpaqueChannel
from ndscan.experiment import make_fragment_scan_exp

import numpy as np
from numpy import int64

from awgsegmentfactory import AWGProgramBuilder
from awgsegmentfactory.debug import format_ir

logger = logging.getLogger(__name__)

def is_ttl_name(s: str) -> bool:
    """
    Check whether a name is likely a hardware TTL (autogenerated),
    assumes <100 TTLs."""
    return s.startswith("ttl") and len(s) > 3 and len(s) < 6 and s[3:].isdigit()


class InitialiseHardware(Fragment):
    """
    Discover and init all hardware once per scan run.
    Has method `safe_off_initial_state` to start hardware in safe state.
    """

    def build_fragment(self):
        self.setattr_device("core")
        self.core: Core

        # host-side guard (survives host_setup being called again on resume)
        self._did_rtio_init = False

        kernel_invariants = getattr(self, "kernel_invariants", set())
        self.kernel_invariants = kernel_invariants | {
            "urukul_cplds", "ad9910s", "suservos", "zotinos", "samplers", "ttls"
        }

    def host_setup(self):
        super().host_setup()

        if self._did_rtio_init:
            return
        self._did_rtio_init = True

        db = self.get_device_db()

        # Discover devices by class name from device_db
        urukul_cpld_names: List[str] = []
        ad9910_names: List[str] = []
        suservo_names: List[str] = []
        suservo_channel_names: List[str] = []
        zotino_names: List[str] = []
        sampler_names: List[str] = []
        ttl_names: List[str] = []

        for name, desc in db.items():
            if not isinstance(desc, (dict)):
                continue
            try:
                cls = desc.get("class", "")
                if cls == "CPLD":
                    urukul_cpld_names.append(name)
                elif cls == "AD9910":
                    ad9910_names.append(name)
                elif cls == "SUServo":
                    suservo_names.append(name)
                elif cls == "Channel":
                    suservo_channel_names.append(name)
                elif cls == "Zotino":
                    zotino_names.append(name)
                elif cls == "Sampler":
                    sampler_names.append(name)
                elif is_ttl_name(name) and cls == "TTLOut":
                    ttl_names.append(name)

            except Exception:
                pass

        # Resolve to device objects (host-side)
        self.urukul_cplds: List[CPLD] = [self.get_device(n) for n in urukul_cpld_names]
        self.ad9910s: List[AD9910] = [self.get_device(n) for n in ad9910_names]
        self.suservos: List[SUServo] = [self.get_device(n) for n in suservo_names]
        self.suservo_channels: List[SUServo] = [self.get_device(n) for n in suservo_channel_names]
        self.zotinos: List[Zotino] = [self.get_device(n) for n in zotino_names]
        self.samplers: List[Sampler] = [self.get_device(n) for n in sampler_names]
        self.ttls: List[TTLOut] = [self.get_device(n) for n in ttl_names]

        logger.info("Init: %d CPLDs, %d AD9910, %d SUServo, %d Zotino, %d Samplers",
                    len(self.urukul_cplds), len(self.ad9910s),
                    len(self.suservos), len(self.zotinos), len(self.samplers))

        # Run the actual init once on the core
        self.rtio_init_all()

    @kernel
    def rtio_init_all(self):
        self.core.break_realtime()

        # Initialise CPLDs of the non-suservo ad9910 chips first.
        #  Resets the DDS I/O interface.
        for cpld in self.urukul_cplds:
            cpld.init()

        # Then DDS channels
        for dds in self.ad9910s:
            dds.init()

        # SUServo devices
        # Initializes the servo, Sampler and both Urukuls (and their cplds).
        # Leaves the servo disabled (see :meth:`set_config`), resets and
        # configures all DDS.
        for suservo in self.suservos:
            suservo.init()

        # DACs
        # Configures the SPI bus, drives LDAC and CLR high, programmes
        # the offset DACs, and enables overtemperature shutdown.
        for zotino in self.zotinos:
            zotino.init()

        # Samplers (Doesn't include SUServo samplers)
        # Initialize the device. Sets up SPI channels.
        for sampler in self.samplers:
            sampler.init()
    
    @kernel
    def safe_off_initial_state(self):
        
        for ttl in self.ttls:
            ttl.off()

        for dds in self.ad9910s:
            dds.sw.off()
            dds.set_att(0*dB)
            dds.set(10*MHz, amplitude = 0.1)

        for zotino in self.zotinos:
            zotino.set_dac([0.0]*32)
        
        for channel in self.suservo_channels:
            channel.set(en_out=0, en_iir=0, profile=0)
            delay(3*us)
            channel.set_y(profile=0, y=0.)

class RbFluoresce(Fragment):

    def build_fragment(self):
        self.setattr_param("cool_frequency",
                           FloatParam,
                           "Cool light AOM drive frequency",
                           110*MHz,
                           min=(110-50)*MHz, max=(110+50)*MHz)
        self.cool_frequency: FloatParamHandle

        self.setattr_param("repump_frequency",
                           FloatParam,
                           "Repump light AOM drive frequency",
                           110*MHz,
                           min=(110-50)*MHz, max=(110+50)*MHz)
        self.repump_frequency: FloatParamHandle

        self.setattr_param("cool_dds_amp",
                           FloatParam,
                           "Cool light AOM DDS amp (0-1)",
                           0.6,
                           min=0, max=1)
        self.cool_dds_amp: FloatParamHandle

        self.setattr_param("repump_dds_amp",
                           FloatParam,
                           "Repump light AOM DDS amp (0-1)",
                           0.6,
                           min=0, max=1)
        self.repump_dds_amp: FloatParamHandle
        
        self.setattr_param("shutter_prefire",
                           FloatParam,
                           "How much time to allow for the shutter coming on, before turning the light on",
                           10*ms,
                           min=0*ms, max=200*ms)
        self.cool_shutter_prefire: FloatParamHandle
        
        self.setattr_device("core")
        self.core: Core
        self.setattr_device("dds_ch_rb_cool")
        self.dds_ch_rb_cool: AD9910
        self.setattr_device("dds_ch_rb_repump")
        self.dds_ch_rb_repump: AD9910
        self.setattr_device("dds_cpld_rb")
        self.dds_cpld_rb: CPLD
        self.setattr_device("ttl_rb_cool_shut")
        self.ttl_rb_cool_shut: TTLOut
        self.setattr_device("ttl_rb_repump_shut")
        self.ttl_rb_repump_shut: TTLOut
    
    # --- In seq action funcs ---

    @kernel
    def apply_dds_settings(self):
        """
        Changes the DDS parameters to a different freq/amp. Ideally the attenuator doesn't need to change
        mid sequence, but is allowed to. This function can be used alone to just change the beam freq/amp
        without changing the state of the RF switches.
        """
        self.dds_ch_rb_cool.set(self.cool_frequency.use(), amplitude=self.cool_dds_amp.use())
        self.dds_ch_rb_repump.set(self.repump_frequency.use(), amplitude=self.repump_dds_amp.use())

    @kernel
    def turn_light_on_now(self, pre_open_shutters=True):
        """
        Turn the cool+repump beams on `now`. This function will open the requisite shutters (if asked)
        and RF switches. It writes shutter events in the past, so be sure to have enough slack for this.
        """
        if pre_open_shutters:
            # Write shutter open into the past.
            # You must have sufficient slack for this to work.
            shutter_prefire = self.shutter_prefire.use()
            delay(shutter_prefire) # This doesn't actually wait, just moves the cursor
            self.ttl_rb_cool_shut.on()
            self.ttl_rb_repump_shut.on()
            delay(shutter_prefire)
            # cursor is now back where this was called.
        self.apply_dds_settings()
        # If the switch was already on, this a Noop
        self.dds_ch_rb_cool.sw.on()
        self.dds_ch_rb_repump.sw.on()
    
    @kernel
    def turn_light_off_now(self, close_shutters=True):
        """
        Turn the cool+repump beams off `now`. This function will close the shutters (if asked)
        and RF switches.
        """
        self.dds_ch_rb_cool.sw.off()
        self.dds_ch_rb_repump.sw.off()
        if close_shutters:
            self.ttl_rb_cool_shut.off()
            self.ttl_rb_repump_shut.off()

class SetShims(Fragment):
    """
    Set the shim fields to the given setpoints. This currently uses the DAC to send voltages to
    the control drivers.
    """

    def build_fragment(self):
        self.setattr_param("NS_setpoint",
                           FloatParam,
                           "N/S Shims servo setpoint voltage",
                           0.2*V,
                           min=-10*V, max=+10*V)
        self.NS_setpoint: FloatParamHandle

        self.setattr_param("EW_setpoint",
                           FloatParam,
                           "E/W Shims servo setpoint voltage",
                           0.3*V,
                           min=-10*V, max=+10*V)
        self.EW_setpoint: FloatParamHandle

        self.setattr_param("UD_setpoint",
                           FloatParam,
                           "U/D Shims servo setpoint voltage",
                           0.4*V,
                           min=-10*V, max=+10*V)
        self.UD_setpoint: FloatParamHandle
        
        self.setattr_device("core")
        self.core: Core
        self.setattr_device("zotino0")
        self.zotino0: Zotino

    # -- In Seq action functions --
    @kernel
    def set_shims(self):
        self.zotino0.set_dac(
            [self.NS_setpoint.use(), self.EW_setpoint.use(), self.UD_setpoint.use()],
            [0, 1, 2],
        )

class ShimRamp(Fragment):
    "Linearly ramp shim setpoints between two values"

    def build_fragment(self):
        self.setattr_param("NS_start_setpoint",
                           FloatParam,
                           "N/S Shims servo setpoint voltage at start of ramp",
                           0.2*V,
                           min=-10*V, max=+10*V)
        self.NS_start_setpoint: FloatParamHandle

        self.setattr_param("NS_end_setpoint",
                           FloatParam,
                           "N/S Shims servo setpoint voltage at end of ramp",
                           0.3*V,
                           min=-10*V, max=+10*V)
        self.NS_end_setpoint: FloatParamHandle

        self.setattr_param("EW_start_setpoint",
                           FloatParam,
                           "E/W Shims servo setpoint voltage at start of ramp",
                           0.4*V,
                           min=-10*V, max=+10*V)
        self.EW_start_setpoint: FloatParamHandle

        self.setattr_param("EW_end_setpoint",
                           FloatParam,
                           "E/W Shims servo setpoint voltage at end of ramp",
                           0.0*V,
                           min=-10*V, max=+10*V)
        self.EW_end_setpoint: FloatParamHandle

        self.setattr_param("UD_start_setpoint",
                           FloatParam,
                           "U/D Shims servo setpoint voltage at start of ramp",
                           0.0*V,
                           min=-10*V, max=+10*V)
        self.UD_start_setpoint: FloatParamHandle

        self.setattr_param("UD_end_setpoint",
                           FloatParam,
                           "U/D Shims servo setpoint voltage at end of ramp",
                           0.0*V,
                           min=-10*V, max=+10*V)
        self.UD_end_setpoint: FloatParamHandle
        
        self.setattr_param("ramp_time",
                           FloatParam,
                           "Ramp time, note the end value will be set at exactly ramp_time after (final dig step length jitter).",
                           10*ms,
                           min=0*us, max=100*ms
                           )
        self.ramp_time: FloatParamHandle
        
        self.setattr_param("step_period",
                           FloatParam,
                           "How long each step of the ADC takes. 1/step_period is the update frequency.",
                           100*us,
                           min=1*us, max=100*ms
                           )
        self.step_period: FloatParamHandle
        
        self.setattr_device("core")
        self.core: Core
        self.setattr_device("zotino0")
        self.zotino0: Zotino

    @kernel
    def ramp_shims(self):

        ramp_time = self.ramp_time.get()
        step_period = self.step_period.get()

        NS0 = self.NS_start_setpoint.get()
        NS1 = self.NS_end_setpoint.get()
        EW0 = self.EW_start_setpoint.get()
        EW1 = self.EW_end_setpoint.get()
        UD0 = self.UD_start_setpoint.get()
        UD1 = self.UD_end_setpoint.get()

        # Degenerate cases
        if ramp_time <= 0*us:
            self.zotino0.set_dac([NS1, EW1, UD1], [0, 1, 2])
            return

        # Linear slope in V/s (units are fine as long as ramp_time is in seconds)
        sNS = (NS1 - NS0) / ramp_time
        sEW = (EW1 - EW0) / ramp_time
        sUD = (UD1 - UD0) / ramp_time

        n_full = int(ramp_time / step_period)   # number of full step_period intervals
        residual = ramp_time - n_full*step_period

        # t = 0
        t = 0.0*s
        self.zotino0.set_dac([NS0, EW0, UD0], [0, 1, 2])

        # t = i*step_period for i=1..n_full
        for _ in range(n_full):
            delay(step_period)
            t += step_period
            self.zotino0.set_dac([NS0 + sNS*t, EW0 + sEW*t, UD0 + sUD*t], [0, 1, 2])

        # Final clamp at exactly ramp_time
        if residual > 0*us:
            delay(residual)
        self.zotino0.set_dac([NS1, EW1, UD1], [0, 1, 2])


class QuadUse(Fragment):
    def build_fragment(self):
        self.setattr_param("quad_setpoint",
                           FloatParam,
                           "Quad setpoint",
                           8*V,
                           min=0*V,max=10*V
                           )
        self.quad_setpoint:FloatParamHandle
    
        self.setattr_device("core")
        self.core: Core
        self.setattr_device("zotino0")
        self.zotino0: Zotino
        self.setattr_device("ttl_quad")
        self.ttl_quad: TTLOut

    @kernel
    def turn_on(self):
        self.zotino0.set_dac([self.quad_setpoint.use()], [3])
        self.ttl_quad.on()

    @kernel
    def change_setpoint(self):
        self.zotino0.set_dac([self.quad_setpoint.use()], [3])
    
    @kernel
    def turn_off(self):
        self.ttl_quad.off()


class LoadRbMOT(Fragment):
    def build_fragment(self):
        self.setattr_fragment("MOT_set_shims", SetShims)
        self.MOT_set_shims: SetShims
        self.setattr_fragment("MOT_quad", QuadUse)
        self.MOT_quad: QuadUse
        self.setattr_fragment("MOT_fluoresce", RbFluoresce)
        self.MOT_fluoresce: RbFluoresce

        self.setattr_device("core")
        self.core: Core

    @kernel
    def load_mot_on(self):
        self.MOT_set_shims.set_shims()
        self.MOT_quad.turn_on()
        self.MOT_fluoresce.turn_light_on_now(pre_open_shutters=True)

    @kernel
    def load_mot_off(self):
        self.MOT_quad.turn_off()
        self.MOT_fluoresce.turn_light_off_now(close_shutters=True)


class LoadRbMOTImage(ExpFragment):
    def build_fragment(self):
        self.setattr_fragment("initialiser", InitialiseHardware) # Just needs to exist here to run
        self.initialiser: InitialiseHardware

        self.setattr_fragment("Rb_MOT_loader", LoadRbMOT)
        self.Rb_MOT_loader: LoadRbMOT

        self.setattr_param("Rb_MOT_preload_time",
                           FloatParam,
                           "How long to load the MOT for before starting exposing the camera",
                           1.0*s,
                           min=1.0*ms,max=10.0*s)
        self.Rb_MOT_preload_time:FloatParamHandle

        self.setattr_param("exposure_time",
                           FloatParam,
                           "How long to expose the camera for",
                           0.5*s,
                           min=0*s,max=10*s)
        self.exposure_time: FloatParamHandle

        # Results
        self.setattr_result("mot_image", OpaqueChannel)

        # Devices
        self.setattr_device("core")
        self.setattr_device("andor_ctrl")
        self.setattr_device("ttl_camera_exposure")

    @kernel
    def rtio_events(self):
        self.core.break_realtime()
        self.initialiser.safe_off_initial_state()
        delay(15*ms) # Add some slack for shutters to open
        
        self.Rb_MOT_loader.load_mot_on()
        delay(self.Rb_MOT_preload_time.use())
        self.ttl_camera_exposure.pulse(self.exposure_time.use())
        self.Rb_MOT_loader.load_mot_off()

    def _configure_camera(self):
        ROI = (0, 511, 0, 511)  # x0, x1, y0, y1 (inclusive)

        with suppress(Exception):
            self.andor_ctrl.abort_acquisition()

        self.andor_ctrl.set_shutter(mode=5)
        self.andor_ctrl.set_trigger_mode(7)   # external exposure
        self.andor_ctrl.set_image_region(*ROI)

    def host_setup(self):
        self._configure_camera()
        super().host_setup()
    
    def run_once(self):
        self.andor_ctrl.start_acquisition()

        self.rtio_events()
        
        self.andor_ctrl.wait()
        img = self.andor_ctrl.get_image16()
        with suppress(Exception):
            self.andor_ctrl.abort_acquisition()

        self.mot_image.push(img)
        self.set_dataset("andor.image", img, broadcast=True)

LoadRbMOTImageExp = make_fragment_scan_exp(LoadRbMOTImage)

class CompressMOT(Fragment):

    def build_fragment(self):
        self.setattr_fragment("shim_ramp_after_MOT", ShimRamp)
        self.setattr_fragment("quad_compression_set",QuadUse)
        self.setattr_device("core")

    @kernel
    def compress(self):
        self.shim_ramp_after_MOT.ramp_shims() # Shim it to where the tweezers are
        self.quad_compression_set.change_setpoint()

class MolassesFields(Fragment):

    def build_fragment(self):
        self.setattr_fragment("molasses_shims", SetShims)
        self.molasses_shims: SetShims
        self.setattr_device("ttl_quad")
        self.ttl_quad: TTLOut
        self.setattr_device("core")

    @kernel
    def change_fields_to_null(self):
        self.molasses_shims.set_shims()
        self.ttl_quad.off()


class AWGContributor:
    def contribute_awg(self, builder: AWGProgramBuilder) -> None:
        return builder  # default: no contribution
    
class AWGOwner(Fragment):
    def build_fragment(self):
        self.setattr_device("AWGTest4Ch")

    def compile_and_upload(self, builder):
        print("Sending following to the card:")
        intent_ir = builder.build_intent_ir()
        print(format_ir(intent_ir))
        intent_ir_dict = intent_ir.encode()
        print("Sending to NDSP...")
        self.AWGTest4Ch.plan_phase_compile_upload(intent_ir_dict)
        print("AWG NDSP finished! :)")


class AWGInitialiser(Fragment, AWGContributor):

    def build_fragment(self):
        self.setattr_device("AWGTest4Ch") # This device API handles upload of seqs

    def contribute_awg(self, builder):
        (
            builder
            .logical_channel("H")
            .logical_channel("V")
            .segment("sync", mode="wait_trig", snap_len_to_quantum=False)
            .hold(
                time=1e-9
            )  # wait_trig defaults: wrap-snap freqs; snap_len_to_quantum=False keeps trigger latency minimal
        )


class SUServoBeamStatic(Fragment):
    """
    Acts purely on the SUServo handle for setting state, does not attempt
    to initialise the hardware.

    For now, this only supports changing setpoint (changing amplitude),
    and we don't use the `profile` feature of SUServo that would allow us
    to switch between various setpoints and integrator states.

    It also assumes a gain of 0 in the calculation of servo setpoint.
    """

    def build_fragment(self, channel: str):
        self.setattr_device("core")
        self.core: Core

        self.suservo_channel: Channel = self.get_device(channel)

        self.setattr_param("setpoint",
            FloatParam,
            "Servo setpoint",
            1*V,
            min=0*V,max=10*V)
        self.setpoint: FloatParam
        
        self.kernel_invariants.add("suservo_channel")

    def host_setup(self):
        super().host_setup()

        self.suservo: SUServo = self.suservo_channel.servo
        
        self.sampler_channel: int = self.suservo_channel.servo_channel
        
        self.kernel_invariants.add("suservo")
        self.kernel_invariants.add("sampler_channel")

    @kernel
    def set_offset(self):
        suservo_offset = -self.setpoint.get() / 10.0
        self.suservo_channel.set_dds_offset(0, suservo_offset)


class SetLoadingTweezers(Fragment, AWGContributor):

    def build_fragment(self):
        self.setattr_device("core")
        self.setattr_device("AWGTest4Ch")
        self.setattr_device("ttl2")

        self.setattr_fragment("loading_beam_power", SUServoBeamStatic, "suservo_ch_817")
        self.loading_beam_power: SUServoBeamStatic

    
    def contribute_awg(self, builder):
        return (
            builder
            .define(
                "loading_H",
                logical_channel="H",
                freqs=np.linspace(92.0e6, 110.0e6, 12),
                amps=[0.08] * 12,
                phases="auto",
            )
            .define("loading_V", logical_channel="V", freqs=[100e6], amps=[0.7], phases="auto")
            .segment("loading_tweezers_on", mode="wait_trig", phase_mode="optimise")
            .tones("H")
            .use_def("loading_H")
            .tones("V")
            .use_def("loading_V")
            .hold(
                time=40e-6
            )
        )

    @kernel
    def rtio_actions(self):
        self.ttl2.pulse(100*us) # Leave previous loop and start doing this
        # this segment also sets the power of the laser amplitude servo
        self.loading_beam_power.set_offset()

class LoadMOTToTweezers(Fragment,AWGContributor):

    def build_fragment(self):
        self.setattr_device("core")

        self.setattr_fragment("Rb_MOT_loader", LoadRbMOT)
        self.setattr_fragment("Rb_MOT_compressor", CompressMOT)
        self.setattr_fragment("Rb_molasses_fields", MolassesFields)
        self.Rb_molasses_fields: MolassesFields
        self.setattr_fragment("init_817_awg", AWGInitialiser)
        self.setattr_fragment("turn_817_arr_on", SetLoadingTweezers)
        
        self.setattr_param("Rb_MOT_load_time",
                    FloatParam,
                    "How long to load the MOT for",
                    100*ms,
                    min=1*ms,max=10*s)

        self.setattr_param("Rb_molasses_time",
                    FloatParam,
                    "How long to do molasses stage",
                    30*ms,
                    min=1*ms,max=10*s)
        
        self.setattr_param("tweezer_depth",
                           FloatParam,
                           "How deep tweezer is throughout",
                           8*V,
                           min=0*V, max=10*V
                           )
        
        
        # Bind the start of CompressMOT to the end of LoadRbMOT
        for dir in ['NS', 'EW', 'UD']:
            handle = self.setattr_param_like(f"loading_{dir}_setpoint", self.Rb_MOT_loader.MOT_set_shims, f"{dir}_setpoint")
            self.Rb_MOT_loader.MOT_set_shims.bind_param(f"{dir}_setpoint", handle)
            self.Rb_MOT_compressor.shim_ramp_after_MOT.bind_param(f"{dir}_start_setpoint", handle)

    
    def contribute_awg(self, builder):
        self.init_817_awg.contribute_awg(builder)
        self.turn_817_arr_on.contribute_awg(builder)
    
    @kernel
    def load_mot_to_tweezers(self):
        delay(20*ms) # Add some slack for shutters to open
        
        # Start MOT load & Turn tweezers on
        self.Rb_MOT_loader.load_mot_on() 
        self.turn_817_arr_on.rtio_actions() # Turns servo on, and triggers into start AWG seg
        delay(self.Rb_MOT_load_time.get())

        # Compress the MOT with increased Quad and temporal dark MOT
        # This step also shims the MOT to where the tweezers are.
        self.Rb_MOT_compressor.compress() 

        # Turn the Quad coils off, set shims to zero field, for molasses/PGRC.
        self.Rb_molasses_fields.change_fields_to_null()
        delay(self.Rb_molasses_time.get())

        self.Rb_MOT_loader.load_mot_off()
        # At this point, there will be tweezers on, ideally with atoms in.

####################################

class ImageAtomsInTweezers(Fragment):

    def build_fragment(self):
        self.setattr_device("core")
        self.setattr_fragment("fluorecense_light", RbFluoresce)
        self.fluorecense_light: RbFluoresce
        self.setattr_device("ttl_camera_exposure")

        self.setattr_param("exposure_time", 
                           FloatParam, 
                           "How long to fluoresce and expose", 
                           20*ms, min=1*ms, max=400*ms)

    @kernel
    def fluoresce_and_expose(self):
        self.fluorecense_light.turn_light_on_now(pre_open_shutters=False)
        self.ttl_camera_exposure.on()
        delay(self.exposure_time.use())
        self.ttl_camera_exposure.off()
        self.fluorecense_light.turn_light_off_now(close_shutters=True)


class LoadMOTToTweezersImage(ExpFragment):

    def build_fragment(self):
        self.setattr_fragment("initialiser", InitialiseHardware) # Just needs to exist here to run
        self.initialiser: InitialiseHardware

        self.setattr_fragment("load_mot_to_twe", LoadMOTToTweezers)
        self.setattr_fragment("image_0", ImageAtomsInTweezers)
        self.setattr_fragment("awg_owner", AWGOwner)
        # self.setattr_fragment("image_twe_after_mot", DualImageCool)
        self.setattr_device("andor_ctrl")
        self.setattr_device("ttl_camera_exposure")
        self.setattr_device("core")

        self.setattr_result("tweezers_image", OpaqueChannel)

    def _configure_camera(self):
        ROI = (0, 511, 0, 511)  # x0, x1, y0, y1 (inclusive)

        with suppress(Exception):
            self.andor_ctrl.abort_acquisition()

        self.andor_ctrl.set_shutter(mode=5)
        self.andor_ctrl.set_trigger_mode(7)   # external exposure
        self.andor_ctrl.set_image_region(*ROI)

    def host_setup(self):
        super().host_setup()
        self._configure_camera()

    @kernel
    def rtio_events(self):
        self.core.break_realtime()
        self.load_mot_to_twe.load_mot_to_tweezers()
        delay(1*ms) # Allow MOT atoms to fly away
        self.image_0.fluoresce_and_expose()


    def contribute_awg(self, builder):
        self.load_mot_to_twe.contribute_awg(builder) 

    def run_once(self):
        # Program AWG
        b = AWGProgramBuilder()
        self.contribute_awg(b) 
        self.awg_owner.compile_and_upload(b)

        # Start Camera acquisition (This will open ths shutter)
        self.andor_ctrl.start_acquisition()

        # Do RTIO stuff to make a MOT and take picture
        self.rtio_events()

        # Wait for camera SDK to give image back
        self.andor_ctrl.wait()
        img = self.andor_ctrl.get_image16()
        with suppress(Exception):
            self.andor_ctrl.abort_acquisition()

        # Push image into dataset and HDF5
        self.tweezers_image.push(img)
        self.set_dataset("andor.image", img, broadcast=True)


LoadMOTToTweezersImageTEMPExp = make_fragment_scan_exp(LoadMOTToTweezersImage)